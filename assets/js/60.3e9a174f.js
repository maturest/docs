(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{353:function(s,e,t){"use strict";t.r(e);var n=t(14),a=Object(n.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"列表的索引与切片"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#列表的索引与切片"}},[s._v("#")]),s._v(" 列表的索引与切片")]),s._v(" "),e("p",[s._v("索引用来对单个元素进行访问，切片则对一定范围内的元素进行访问，切片通过冒号在中括号内把相隔的两个索引查找出来。")]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("numbers = [1,2,3,4,5,6,7,8,9,10]\n\nprint(numbers[3:8])\n\nnumbers[:]\n\nnumbers[0:]\n\nnumbers[:-1]\n\nnumbers[::-1] # 列表的返序\n\nnumbers[-3:-1]\n\nnumbers[0:8:2] # 从0到8，每次步长2\n\nnumbers[0:0] # 切片生成空列表\n")])])]),e("p",[e("strong",[s._v("切片规则：左含，右不含")])]),s._v(" "),e("p",[s._v("列表的索引获取与修改")]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("list[index] = new_item\n\nlist[2:5] = ['a','b','c']\n")])])]),e("p",[s._v("列表无法通过添加新的索引的方式赋值")]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("# 返回 item 在列表中的索引位置\nlist.index(item)\n")])])]),e("p",[s._v("pop 通过索引删除并获取列表的元素,它会删除该元素的索引并返回")]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("list.pop(index)\n")])])]),e("p",[s._v("del 删除索引")]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("del list[index]\n")])])]),e("p",[s._v("索引切片在元组中的特殊性")]),s._v(" "),e("ul",[e("li",[s._v("可以和列表一样获取索引与切片索引")]),s._v(" "),e("li",[s._v("元组函数 index 和列表用法完全一致")]),s._v(" "),e("li",[s._v("无法通过索引修改与删除元素（元组是不可改变的）")])])])}),[],!1,null,null,null);e.default=a.exports}}]);